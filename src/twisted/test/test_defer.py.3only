# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.

"""
Test cases for L{twisted.internet.defer} on Python 3.5 and later.

This file is loaded by C{test_defer.py} only when running on an
interpreter version that supports the C{async} and C{await} keywords.
"""


import functools

from twisted.internet import defer
from twisted.internet.task import Clock
from twisted.python.reflect import requireModule
from twisted.trial import unittest


contextvars = requireModule('contextvars')
if contextvars:
    contextvarsSkip = None
else:
    contextvarsSkip = "contextvars is not available"


def ensuringDeferred(f):
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        result = f(*args, **kwargs)
        return defer.ensureDeferred(result)
    return wrapper



class DeferredTestsAsync(unittest.TestCase):

    @ensuringDeferred
    async def test_asyncWithLock(self):
        """
        L{defer.DeferredLock} can be used as an asynchronous context manager.
        """
        lock = defer.DeferredLock()
        async with lock:
            self.assertTrue(lock.locked)
            d = lock.acquire()
            d.addCallback(lambda _: lock.release())
            self.assertTrue(lock.locked)
            self.assertFalse(d.called)
        self.assertTrue(d.called)
        await d
        self.assertFalse(lock.locked)


    @ensuringDeferred
    async def test_asyncWithSemaphore(self):
        """
        L{defer.DeferredSemaphore} can be used as an asynchronous context manager.
        """
        sem = defer.DeferredSemaphore(3)

        async with sem:
            self.assertEqual(sem.tokens, 2)
            async with sem:
                self.assertEqual(sem.tokens, 1)
                d1 = sem.acquire()
                d2 = sem.acquire()
                self.assertEqual(sem.tokens, 0)
                self.assertTrue(d1.called)
                self.assertFalse(d2.called)
            self.assertEqual(sem.tokens, 0)
            self.assertTrue(d2.called)
            d1.addCallback(lambda _: sem.release())
            d2.addCallback(lambda _: sem.release())
            await d1
            await d2
            self.assertEqual(sem.tokens, 2)
        self.assertEqual(sem.tokens, 3)

    @ensuringDeferred
    async def test_asyncWithLockException(self):
        """
        C{defer.DeferredLock} correctly propagates exceptions when
        used as an asynchronous context manager.
        """
        lock = defer.DeferredLock()
        with self.assertRaisesRegexp(Exception, 'some specific exception'):
            async with lock:
                self.assertTrue(lock.locked)
                raise Exception('some specific exception')
        self.assertFalse(lock.locked)

    def test_contextvarsWithAsyncAwait(self):
        """
        When a coroutine is called, the context is taken from when it was first
        called. When it resumes, the same context is applied.
        """
        clock = Clock()

        var = contextvars.ContextVar("testvar")
        var.set(1)

        # This Deferred will set its own context to 3 when it is called
        mutatingDeferred = defer.Deferred()
        mutatingDeferred.addCallback(lambda _: var.set(3))

        mutatingDeferredThatFails = defer.Deferred()
        mutatingDeferredThatFails.addCallback(lambda _: var.set(4))
        mutatingDeferredThatFails.addCallback(lambda _: 1 / 0)

        # context is 1 when the function is defined
        async def testFunction():

            # Expected to be 2
            self.assertEqual(var.get(), 2)

            # Does not mutate the context
            await defer.succeed(1)

            # Expected to be 2
            self.assertEqual(var.get(), 2)

            # mutatingDeferred mutates it to 3, but only in its Deferred chain
            clock.callLater(0, mutatingDeferred.callback, True)
            await mutatingDeferred

            # When it resumes, it should still be 2
            self.assertEqual(var.get(), 2)

            # mutatingDeferredThatFails mutates it to 3, but only in its Deferred chain
            clock.callLater(0, mutatingDeferredThatFails.callback, True)
            try:
                await mutatingDeferredThatFails
            except:
                self.assertEqual(var.get(), 2)
            else:
                raise Exception("???? should have failed")

            return True

        # The inlineCallbacks context is 2 when it's called
        var.set(2)
        d = defer.ensureDeferred(testFunction())

        # Advance the clock so mutatingDeferred triggers
        clock.advance(1)

        # Advance the clock so that mutatingDeferredThatFails triggers
        clock.advance(1)

        self.assertEqual(self.successResultOf(d), True)

    test_contextvarsWithAsyncAwait.skip = contextvarsSkip
